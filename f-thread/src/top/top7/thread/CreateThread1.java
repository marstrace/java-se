package top.top7.thread;

/******
 *       Created by LEARNING on 2020/11/4 12:10.
 *
 **********************************************************************
 *                .-~~~~~~~~~-._       _.-~~~~~~~~~-.
 *            __.'              ~.   .~              `.__
 *          .'//                  \./                  \\`.
 *        .'//                     |                     \\`.
 *      .'// .-~"""""""~~~~-._     |     _,-~~~~"""""""~-. \\`.
 *    .'//.-"                 `-.  |  .-'                 "-.\\`.
 *  .'//______.============-..   \ | /   ..-============.______\\`.
 *.'______________________________\|/______________________________`.
 *
 *
 *                     Don't forget to be awesome!                      
 **********************************************************************
 */

/**
 * 实现线程的第一种方式:
 * 编写一个类,直接继承java.lang.Thread类,并重写run()方法
 */
public class CreateThread1 {
    public static void main(String[] args) {
        //这里是main方法,这里的代码属于主线程,在主栈中运行

        //创建自定义线程对象:
        //新建一个分支线程对象
        MyThread1 myThread1 = new MyThread1();

        //使用从Thread类继承来的start()方法启动线程:
        //start()方法的作用是:启动一个分支线程,在jvm中开辟一个新的栈空间,这段代码任务完成之后,瞬间就结束了
        //这段代码的任务只是为了开辟新的栈空间,只要新的栈空间开出来,start()方法就结束了
        //启动成功的线程会自动调用run方法,并且run方法在分支栈的栈底部(压栈)
        //run方法在分支栈的栈底部,main方法在主栈的栈底部.run方法和main方法是平级的
        //直接调用run()方法不会启动线程,不会分配新的分支栈,(这种方式就是单线程)
        myThread1.start();
    }
}


/**
 * 编写线程类:
 * 编写类,继承java.lang.Thread类,并重写run()方法
 */
class MyThread1 extends Thread {
    //重写run()方法
    @Override
    public void run() {//子类重写父类方法抛出的异常不能大于父类,因此此处不能抛出异常
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}